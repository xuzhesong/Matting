clc;
clear;
close all;

rgb_path = 'test/GT01_image.png';
trimap_path = 'test/GT01_trimap.png';
rgb = imread(rgb_path);
trimap = imread(trimap_path);
%%
tic;
alpha = calculate_alpha(rgb_path, trimap_path, 8, 30);
toc;
%%
% Display the result
gt = imread("./test/GT01.png");
figure(1);

subplot(2,2,1);
imshow(rgb);

subplot(2,2,2);
imshow(trimap);

subplot(2,2,3);
imshow(gt);

subplot(2,2,4);
imshow(alpha);

mse = MSE(alpha, double(gt));
disp(mse);

%% calculate connectivty error
% cError = ConnectivityError(alpha, gt);
% disp(cError);
tic;
Ip = alpha;
Ir = double(gt/255);
conn_error = ConnectivityError(Ip, Ir, 0.15, 1, 0.15);
disp(conn_error);
toc;
% function conn_error = calculate_connectivity_error(alpha, alpha_star, theta, p, k)
%     
%     if ndims(alpha) == 3
%         alpha = rgb2gray(alpha);
%     end
%     if ndims(alpha_star) == 3
%         alpha_star = rgb2gray(alpha_star);
%     end
%     % 计算源域
%     source_domain = calculate_source_domain(alpha, alpha_star);
% 
%     % 计算 lambda
%     
%     lambda = calculate_lambda(alpha, source_domain, k);
%     
%     % 计算每个像素的Connectivity Error
%     phi_alpha = phi(alpha, lambda, theta);
%     phi_alpha_star = phi(alpha_star, lambda, theta);
%     
%     % 计算总的Connectivity Error
%     conn_error = sum(abs(phi_alpha(:) - phi_alpha_star(:)).^p) / numel(alpha);;
% end
% 
% function phi_values = phi(alpha_values, lambda, theta)
%     % 为矩阵 alpha 计算 phi 函数值
%     Omega = 1; % 完全不透明的阈值
%     d_values = abs(alpha_values - Omega); % 计算 d_i 矩阵
%     phi_values = 1 - lambda * (d_values >= theta) .* d_values; % 计算 phi 值矩阵
% end
% 
% function lambda = calculate_lambda(alpha, source_domain, k)
%     % 计算 lambda 值
%     % alpha是一个二维矩阵
%     % source_domain是计算出的最大连通源域
%     % k是用于确定最近像素的阈值，这里可能未用到，取决于D函数的定义
%     
%     N = numel(alpha); % alpha中的像素总数
%     [rows, cols] = find(source_domain); % 找到源域中的像素位置
%     source_domain_coords = [rows, cols]; % 源域像素的二维坐标
%     lambda_sum = 0;
%     
%     for i = 1:size(alpha, 1)
%         for j = 1:size(alpha, 2)
%             % 如果当前像素属于源域，则距离为0
%             if source_domain(i, j)
%                 lambda_sum = lambda_sum + 0;
%             else
%                 % 调用D函数计算当前像素到源域的距离
%                 dist_ij = D([i, j], source_domain_coords); 
%                 lambda_sum = lambda_sum + dist_ij;
%             end
%         end
%     end
%     
%     lambda = lambda_sum / N; % 标准化lambda值
% end
% 
% function dist_ij = D(pixel_coords, source_domain_coords)
%     % 如果源域为空，定义一个很大的距离
%     if isempty(source_domain_coords)
%         dist_ij = inf; 
%         return;
%     end
%     
%     % 计算给定像素与源域像素之间的最小欧式距离
%     distances = sqrt(sum((source_domain_coords - pixel_coords).^2, 2));
%     dist_ij = min(distances); % 选择最小的距离
% end
% 
% function source_domain = calculate_source_domain(alpha_pred, alpha_true)
%     % 找到预测结果和真值共有的值为1的连通区域
%     common_area = alpha_pred & alpha_true; % 共有区域
%     CC = bwconncomp(common_area); % 找到连通区域
%     numPixels = cellfun(@numel, CC.PixelIdxList); % 计算每个区域的像素数量
%     [~, idx] = max(numPixels); % 找到最大连通区域的索引
%     source_domain = false(size(alpha_pred)); % 初始化源域
%     source_domain(CC.PixelIdxList{idx}) = true; % 设置最大连通区域为源域
% end
